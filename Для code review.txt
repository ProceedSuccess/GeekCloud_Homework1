package com.GeekCloud.server;

public class Server {
    public Server() {
    }
    public void run() throws Exception {
        EventLoopGroup mainGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(mainGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer<SocketChannel>() {
                        protected void initChannel(SocketChannel socketChannel) throws Exception {
                            socketChannel.pipeline().addLast(
                                    new ObjectEncoder(),
                                    new OutboundHandler(),
                                    new ObjectDecoder(20 * 1024 * 1024, ClassResolvers.cacheDisabled(null)),
                                    new InboundHandler()
                                    );
                        }
                    })
                    .option(ChannelOption.SO_BACKLOG, 128)
                    .option(ChannelOption.TCP_NODELAY, true)
                    .childOption(ChannelOption.SO_KEEPALIVE, true);
            ChannelFuture future = b.bind(8189).sync();
            future.channel().closeFuture().sync();
        } finally {
            mainGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
    public static void main(String[] args) throws Exception {
        Class.forName("org.sqlite.JDBC").getDeclaredConstructor().newInstance();
        new Server().run();
    }
}
package com.GeekCloud.server;

public class InboundHandler extends ChannelInboundHandlerAdapter {
    private static Connection con;
    private static Statement stmt;
    private static ResultSet rs;

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        FileOutputStream fous;
        //поток для записи входящих файлов на диск
        try {
            if (msg == null) {
                return;
            }
            // запрос на скачивание файла с сервера
            if (msg instanceof FileRequest) {
                FileRequest fr = (FileRequest) msg;
                if (Files.exists(Paths.get("server_storage\\" + fr.getFilename()))) {
                    //отправляем пустое сообщение исходящему хэндлеру
                    FileMessage fm = new FileMessage(Paths.get("server_storage\\" + fr.getFilename()));
                    System.out.println("file name: " + fm.getFilename());
                    ctx.writeAndFlush(fm);
                }
                ReferenceCountUtil.release(msg);
            }
            // получение файла от клиента (проверить, кушает ли создание каждый раз
            // FileOutputStream память
            if (msg instanceof FileMessage) {
                if (msg == null) return;
                fous = new FileOutputStream("server_storage\\" + ((FileMessage) msg).getFilename(),true);
                byte[] b = ((FileMessage) msg).getData();
                fous.write(b);
                fous.close();
                ctx.flush();
            }
            //сообщение с логином/паролем
            if (msg instanceof AuthorizationMessage){
                PermissionMessage pm;
                if (((AuthorizationMessage) msg).getNickname() != null){
                    System.out.println("nickname is "+((AuthorizationMessage) msg).getNickname());
                    pm = DataBaseRequestor.createAccount(((AuthorizationMessage) msg).getLogin(),
                            ((AuthorizationMessage) msg).getPassword(),((AuthorizationMessage) msg).getNickname());
                    System.out.println(pm.getAccess());
                }
                else {pm = DataBaseRequestor.query(((AuthorizationMessage) msg).getLogin(),
                                        ((AuthorizationMessage) msg).getPassword());}
                ctx.writeAndFlush(pm);
                ReferenceCountUtil.release(msg);
            }
        } finally {
            ReferenceCountUtil.release(msg);
        }
    }
    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
        ctx.flush();
    }
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        ctx.close();
    }
}
public class OutboundHandler extends ChannelOutboundHandlerAdapter {
    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
        if (msg instanceof PermissionMessage){
        PermissionMessage pm = (PermissionMessage)msg;
        System.out.println("access: " + pm.getAccess());
        ctx.writeAndFlush(pm);
        }
        if (msg instanceof FileMessage){
            FileMessage fm = (FileMessage)msg;
            try {
                int numberOfParts = fm.splitFileMessage(fm.getPath(),"server_storage\\"); // объем одной части файла
                RandomAccessFile raf = new RandomAccessFile("server_storage\\" + fm.getFilename(),"r");
                byte[] data = new byte[(int)raf.length()/numberOfParts];
                System.out.println("file size: " + raf.length());
                try{
                    while(raf.read(data) != -1){
                        ctx.writeAndFlush(new FileMessage(fm.getFilename(),data));
                        ReferenceCountUtil.release(msg);
                    }
                    ctx.writeAndFlush(null);
                    System.out.println("file sent successfully");
                }catch (EOFException e){}
            }catch (IOException e) {
                e.printStackTrace();
            }
            ctx.writeAndFlush(fm);
        }
    }
}
package com.GeekCloud.server;

import com.GeekCloud.common.PermissionMessage;
import java.sql.*;
// Класс, работающий с БД
public class DataBaseRequestor {
    // Class.forName("org.sqlite.JDBC").getDeclaredConstructor().newInstance();
    // - выполняется при запуске сервера
    private static Connection con;
    private static Statement stmt;
    private static ResultSet rs;
    //для SELECT
    static String queryLogin = "SELECT login FROM Users1 where login";
    static String queryPassword = "SELECT password FROM Users1 WHERE password";
    // Для CREATE
    static String createLoginPassword = "INSERT INTO Users1 (id_,login,password,nickname) VALUES";

    static boolean loginIsValid = false;
    static boolean passwordIsValid = false;
    static boolean valid = false;
    // метод работает, в случае, если огин/пароль совпадают
    public static PermissionMessage query(String login, String password){
        try{
            con = DriverManager.getConnection( "jdbc:sqlite:data.db");
            stmt = con.createStatement();
            rs = stmt.executeQuery(queryLogin + "=" +"'" + login + "'");
            // проверка логина
            if (rs.getString(1)
                    .equals((login))){
                loginIsValid = true;
            }
            rs = stmt.executeQuery(queryPassword + "=" +"'" + password+ "'");
            // проверка пароля
            if (rs.getString(1)
                    .equals((password))){
                passwordIsValid = true;
            }
            if (loginIsValid && passwordIsValid){
                System.out.println("login,password are valid");
                valid = true;
            }
            if (!loginIsValid && passwordIsValid){
                System.out.println("no such user");
                valid = false;
            }
        }
        catch (SQLException sqlEx) {
            System.out.println("try again");
            sqlEx.printStackTrace();
        }
//        finally {
//            try { con.close(); } catch(SQLException se) { se.printStackTrace(); }
//            try { stmt.close(); } catch(SQLException se) { se.printStackTrace(); }
//            try { rs.close(); } catch(SQLException se) { se.printStackTrace(); }
//        }
        return new PermissionMessage(valid);
    }
    public static PermissionMessage createAccount(String login, String password, String nickName){
        try{
            con = DriverManager.getConnection( "jdbc:sqlite:data.db");
            stmt = con.createStatement();
            rs = stmt.executeQuery(createLoginPassword + " (" + 4 +  "," + "'" +  login + "'" + ","
                    + "'"+  password + "'" + ","+ "'"+  nickName + "'"+ ");");
            for (int i = 0; i < 4; i++) {
                System.out.println(rs.getString(i));
            }

        }catch (SQLException e){
            e.printStackTrace();
        }
        return new PermissionMessage(true);
    }
}
package com.GeekCloud.common;

import java.io.Serializable;

public abstract class AbstractMessage implements Serializable {
    protected static final long serialVersionUID = 5193392663743561680L;
}

public class AuthorizationMessage extends AbstractMessage {
    private String login;
    private String password;
    private String nickname;
    public String getLogin(){return login;}
    public String getPassword(){return password;}
    public String getNickname(){return nickname;}

    public AuthorizationMessage(String log, String pass){
        this.login = log;
        this.password = pass;
    }
    public AuthorizationMessage(String log, String pass, String nickname){
        this.login = log;
        this.password = pass;
        this.nickname = nickname;
    }
    public String toString(){
        return (this.login + " " + this.password);
    }
}
package com.GeekCloud.common;

import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.file.Path;

public class FileMessage extends AbstractMessage {
    private String filename;
    private byte[] data;
    private long onePartLength;
    private Path path;

    public String getFilename() {
        return filename;
    }
    public byte[] getData() {
        return data;
    }
    public int getDataSize(){ return data.length;}
    public long getOnePartLength(){return onePartLength;}
    public Path getPath(){return path;}

    public FileMessage(Path path) {
        this.filename = path.getFileName().toString();
        this.path = path;
    }
    public FileMessage(String filename,byte[] data){
        this.filename = filename;
        this.data = data;
    }
    //надо придумать более эффективынй алгоритм оценки и разбиения файла
    public int splitFileMessage(Path path, String sourсe) throws IOException {
        filename = path.getFileName().toString();
        RandomAccessFile raf = new RandomAccessFile(sourсe + filename, "r");
        // оцениваем размер файла (насколько затратна операция сравнения?поменять порядок?)
            if(raf.length() > 10*1024*1024*1024){
                onePartLength = raf.length()/ 4096;
            }else if (raf.length() > 1024*1024*1024 && raf.length() < 10*1024*1024*1024) {
                onePartLength = raf.length()/ 2048;
            }else if (raf.length() > 256*1024*1024 && raf.length() < 1024*1024*1024){
                // разбиваем на части
                onePartLength = raf.length()/ 1024;
            }else if (raf.length() < 256 * 1024 *1024 && raf.length() > 128*1024*1024){
                onePartLength = raf.length()/ 64;
            }else if (raf.length() < 128 * 1024 *1024 && raf.length() > 16*1024*1024){
                onePartLength = raf.length()/ 32;
            }else onePartLength = raf.length() / 8;
        System.out.println("length of one part: " + onePartLength);
        System.out.println("number of parts: " + (int)(raf.length()/ onePartLength));
        // возвращаем длину одной части отправляемого файла
            return (int)raf.length()/(int) onePartLength;
    }
}
package com.GeekCloud.common;
public class FileRequest extends AbstractMessage {
    private String filename;
    public String getFilename() {
        return filename;
    }
    public FileRequest(String filename) {
        this.filename = filename;
    }
}
package com.GeekCloud.common;
public class PermissionMessage extends AbstractMessage {
    private boolean access;
    public boolean getAccess(){return access;}
    public PermissionMessage(boolean access){
        this.access = access;
    }
}
package com.GeekCloud.client;

public class AuthController implements Initializable {
    @FXML
    Button logIn;
    @FXML
    Button signIn;
    private static Network network;
    public static Network getNetwork(){return network;}

    CreateNewWindow createNewWindow;

    @Override
    public void initialize(URL location, ResourceBundle resources) {
        createNewWindow = new CreateNewWindow();
        network = new Network();
        network.start();
        logIn.addEventHandler(MouseEvent.MOUSE_CLICKED, new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent mouseEvent) {
                pressOnLogIn();
            }
        });
        signIn.addEventHandler(MouseEvent.MOUSE_CLICKED, new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent mouseEvent) {
                pressOnSignIn();
            }
        });
    }
    @FXML
    public void pressOnLogIn() {
        if (logIn.isManaged()) {
            System.out.println("log in");
            createNewWindow.create("/com/GeekCloud/Login.fxml", "Enter your login/password:", 400,400);
        }
    }
    public void pressOnSignIn() {
        if (signIn.isManaged()) {
            System.out.println("sign in");
            createNewWindow.create("/com/GeekCloud/SignIn.fxml", "Enter your login/password:", 400,600);
        }
    }
}
package com.GeekCloud.client;

public class CreateNewWindow {
    public void create(String source,String title, int width,int height){
        try{
            Stage stage = new Stage();
            FXMLLoader loader = new FXMLLoader(getClass().getResource(source));
            Parent root = loader.load();
            stage.setTitle(title);
            stage.setScene(new Scene(root, width, height));
            stage.initModality(Modality.APPLICATION_MODAL);
            stage.setResizable(true);
            stage.showAndWait();
        }catch (IOException e){
            e.printStackTrace();
        }
    }
}
public class LogInController implements Initializable {
    protected static Network network;
    @FXML
    TextField login;
    @FXML
    TextField password;
    @FXML
    Button ok;

    String log;
    String pass;

    CreateNewWindow createNewWindow;

    @Override
    public void initialize(URL location, ResourceBundle resources)  {
        createNewWindow = new CreateNewWindow();
        network = AuthController.getNetwork();
        // слушаем сервер на предмет получения ответа на запрос авторизации
        Thread t = new Thread(() -> {
            while(true){
                try {
                    AbstractMessage am = network.readObject();
                    if (am instanceof PermissionMessage) {
                        System.out.println("pm catched!");
                        if(((PermissionMessage) am).getAccess() == true) {
                            openMainScene();
                            break;
                        }else System.out.println("access denied");
                    }
                } catch (ClassNotFoundException | IOException e) {
                    e.printStackTrace();}
            }
        });
        t.setDaemon(true);
        t.start();
    }
//   открываем главную часть приложения
    public void openMainScene() {
        Platform.runLater(() -> {
            createNewWindow.create
                    ("/com/GeekCloud/main.fxml",
                            "Choose file to download/upload:",
                            600,800);
        });
    }
    public void sendLoginPassword(ActionEvent actionEvent){
        if (login.getLength() > 0 && password.getLength() >0 && ok.isArmed()) {
            log = login.getText();
            pass = password.getText();
            AuthorizationMessage am = new AuthorizationMessage(log,pass);
            System.out.println(log + " " + pass);
            network.sendMsg(am);
        }
    }
}
public class MainClient extends Application {
    @Override
    public void start(Stage primaryStage) throws Exception{
        FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource("/com/GeekCloud/Authorization.fxml"));
        Parent root = fxmlLoader.load();
        primaryStage.setTitle("Do you have an account?");
        Scene scene = new Scene(root);
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
package com.GeekCloud.client;

import com.GeekCloud.common.AbstractMessage;
import com.GeekCloud.common.FileMessage;
import com.GeekCloud.common.FileRequest;
import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.Button;
import javafx.scene.control.ListView;
import javafx.scene.control.TextField;

import java.io.FileOutputStream;
import java.io.IOException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.ResourceBundle;

public class MainController implements Initializable {
    @FXML
    TextField tfFileName;
    @FXML
    TextField tfLoadFile;
    @FXML
    ListView<String> clientFilesList;
    @FXML
    ListView<String> serverFilesList;
    @FXML
    Button download;
    @FXML
    Button upload;
   private Network network;
    @Override
    public void initialize(URL location, ResourceBundle resources) {
        network = AuthController.getNetwork();
        System.out.println("initialize main scene");
        Thread t = new Thread(() -> {
            try {
                while (true) {
                    AbstractMessage am = Network.readObject();
//                    if (am instanceof FileMessage && ((FileMessage) am).getOnePartLength() != 0){
//                        System.out.println(((FileMessage) am).getOnePartLength());
//                    }
                    if (am instanceof FileMessage) {
                        if (am == null) {
                            System.out.println("file catched");
                            continue;}
                        FileMessage fm = (FileMessage) am;
                        FileOutputStream fous = new FileOutputStream("client_storage\\" + ((FileMessage) fm).getFilename(),true);;
                        byte[] b =  fm.getData();
                        fous.write(b);
                      //  fous.close();
//                        Files.write(Paths.get("client_storage\\"
//                                + fm.getFilename()), fm.getData(), StandardOpenOption.CREATE);
                        refreshLocalFilesList();
                    }
                }
            } catch (ClassNotFoundException | IOException e) {
                e.printStackTrace();
            } finally {
              //  network.stop();
            }
        });
        t.setDaemon(true);
        t.start();
        clientFilesList.setItems(FXCollections.observableArrayList());
        serverFilesList.setItems(FXCollections.observableArrayList());
        refreshLocalFilesList();
        refreshServerFilesList();
    }

    public void pressOnDownloadBtn(ActionEvent actionEvent) {
        if (tfFileName.getLength() > 0 && download.isArmed()) {
            Network.sendMsg(new FileRequest(tfFileName.getText()));
            System.out.println("file request sent");
            tfFileName.clear();
        }
    }
    public void pressOnUploadBtn(ActionEvent actionEvent) throws IOException {
        if (tfLoadFile.getLength() > 0 && upload.isArmed()) {
            Network.sendFileMsg(new FileMessage(Paths.get("client_storage\\" + tfLoadFile.getText())));
         //   System.out.println(" file message sent");
            tfLoadFile.clear();
            refreshServerFilesList();
        }
    }
    public void refreshLocalFilesList() {
        if (Platform.isFxApplicationThread()) {
            try {
                clientFilesList.getItems().clear();
                Files.list(Paths.get("client_storage")).map(p -> p.getFileName().toString()).forEach(o -> clientFilesList.getItems().add(o));
            } catch (IOException e) {
                e.printStackTrace();
            }
        } else {
            Platform.runLater(() -> {
                try {
                    clientFilesList.getItems().clear();
                    Files.list(Paths.get("client_storage")).map(p -> p.getFileName().toString()).forEach(o -> clientFilesList.getItems().add(o));
                } catch (IOException e) {
                    e.printStackTrace();
                }
            });
        }
    }
    public void refreshServerFilesList() {
        if (Platform.isFxApplicationThread()) {
            try {
                serverFilesList.getItems().clear();
                Files.list(Paths.get("server_storage")).map(p -> p.getFileName().toString()).forEach(o -> serverFilesList.getItems().add(o));
            } catch (IOException e) {
                e.printStackTrace();
            }
        } else {
            Platform.runLater(() -> {
                try {
                    serverFilesList.getItems().clear();
                    Files.list(Paths.get("server_storage")).map(p -> p.getFileName().toString()).forEach(o -> serverFilesList.getItems().add(o));
                } catch (IOException e) {
                    e.printStackTrace();
                }
            });
        }
    }
}
package com.GeekCloud.client;

public class Network {
    private static Socket socket;
    private static ObjectEncoderOutputStream out;
    private static ObjectDecoderInputStream in;

    public void start() {
        try {
            System.out.println("Network started");
            socket = new Socket("localhost", 8189);
            out = new ObjectEncoderOutputStream(socket.getOutputStream());
            in = new ObjectDecoderInputStream(socket.getInputStream(),1048*1048*64);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    public void stop() {
        try {
            out.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            in.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static boolean sendMsg(AbstractMessage msg) {
        try {
            out.writeObject(msg);
            System.out.println("auth/filerequest msg sent");
            return true;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return false;
    }
    // отправка файлов
    public static boolean sendFileMsg(FileMessage msg) {
        try {
            int onePartOfMsg = msg.splitFileMessage(msg.getPath(),"client_storage\\"); // объем одной части файла
            RandomAccessFile raf = new RandomAccessFile("client_storage\\" + msg.getFilename(),"r");
            byte[] data = new byte[(int)raf.length()/onePartOfMsg];
            System.out.println("file size: " + raf.length());
            try{
                while(raf.read(data) != -1){
                    out.writeObject(new FileMessage(msg.getFilename(),data));
                 }
                System.out.println("file sent successfully");
                // посылаем серверу сигнал о конце файла
                out.writeObject(null);
                out.close();
                return true;
                }catch (EOFException e){}
        }catch (IOException e) {
            e.printStackTrace();
        }
        return false;
    }
    public static AbstractMessage readObject() throws ClassNotFoundException, IOException {
        Object obj = in.readObject();
     //   System.out.println("msg read");
        return (AbstractMessage) obj;
    }
}
package com.GeekCloud.client;
public class SignInController extends LogInController implements Initializable {
    @FXML
    TextField nickname;
    @FXML
    Button ok;
    String nick;
    @Override
    public void initialize(URL location, ResourceBundle resources) {
        createNewWindow = new CreateNewWindow();
        network = AuthController.getNetwork();
        Thread t = new Thread(() -> {
            while(true){
                try {
                    AbstractMessage am = network.readObject();
                    if (am instanceof PermissionMessage) {
                        System.out.println("pm catched!");
                        if(((PermissionMessage) am).getAccess() == true) {
                            openMainScene();
                            break;
                        }else System.out.println("wrong data or such user already exists");
                    }
                } catch (ClassNotFoundException | IOException e) {
                    e.printStackTrace();}
            }
        });
        t.setDaemon(true);
        t.start();
    }
    @Override
    public void sendLoginPassword(ActionEvent actionEvent) {
        if (login.getLength() > 0 && password.getLength() >0 && nickname.getLength() > 0 && ok.isArmed()) {
            log = login.getText();
            pass = password.getText();
            nick = nickname.getText();
            AuthorizationMessage am = new AuthorizationMessage(log,pass,nick);
            System.out.println(log + " " + pass + " " + nick);
            network.sendMsg(am);
        }
    }
}
